
//This is here to keep the ready from firing before dynamically defined
//Javascript loads

$.holdReady( true );


/* This must load after JQuery */

/*!
 * jQuery htmlDoc "fixer" - v0.2pre - 8/8/2011
 * http://benalman.com/projects/jquery-misc-plugins/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function($) {
  // RegExp that matches opening and closing browser-stripped tags.
  // $1 = slash, $2 = tag name, $3 = attributes
  var matchTag = /<(\/?)(html|head|body|title|base|meta)(\s+[^>]*)?>/ig;
  // Unique id prefix for selecting placeholder elements.
  var prefix = 'hd' + +new Date;
  // A node under which a temporary DOM tree can be constructed.
  var parent;
	
  $.htmlDoc = function(html) {
		
    // A collection of "intended" elements that can't be rendered cross-browser
    // with .innerHTML, for which placeholders must be swapped.
    var elems = $();
    // Input HTML string, parsed to include placeholder DIVs. Replace HTML,
    // HEAD, BODY tags with DIV placeholders.
	
//	console.log("html original : "+html)
	
    var htmlParsed = html.replace(matchTag, function(tag, slash, name, attrs) {
      // Temporary object in which to hold attributes.
      var obj = {};
      // If this is an opening tag...
      if ( !slash ) {
        // Add an element of this name into the collection of elements. Note
        // that if a string of attributes is added at this point, it fails.
        elems = elems.add('<' + name + '/>');
        // If the original tag had attributes, create a temporary div with
        // those attributes. Then, copy each attribute from the temporary div
        // over to the temporary object.
        if ( attrs ) {
          $.each($('<div' + attrs + '/>')[0].attributes, function(i, attr) {				
            obj[attr.name] = attr.value;
          });
        }
        // Set the attributes of the intended object based on the attributes
        // copied in the previous step.
        elems.eq(-1).attr(obj);
      }
      // A placeholder div with a unique id replaces the intended element's
      // tag in the parsed HTML string.
      return '<' + slash + 'div'
        + (slash ? '' : ' id="' + prefix + (elems.length - 1) + '"') + '>';
    });

    // If no placeholder elements were necessary, just return normal
    // jQuery-parsed HTML.
    if ( !elems.length ) {
      return $(html);
    }
    // Create parent node if it hasn't been created yet.
    if ( !parent ) {
      parent = $('<div/>');
    }
    // Create the parent node and append the parsed, place-held HTML.
    parent.html(htmlParsed);
    // Replace each placeholder element with its intended element.
    $.each(elems, function(i) {
      var elem = parent.find('#' + prefix + i).before(elems[i]);
      elems.eq(i).html(elem.contents());
      elem.remove();
    });
    // Return the topmost intended element(s), sans text nodes, while removing
    // them from the parent element with unwrap.
    return parent.children().unwrap();
  };

}(jQuery));



// Copy all atributes over for elements
(function($) {
    // Attrs
    $.fn.attrs = function(attrs) {
        var t = $(this);
        if (attrs) {
            // Set attributes
            t.each(function(i, e) {
                var j = $(e);
                for (var attr in attrs) {
                    j.attr(attr, attrs[attr]);
                };
            });
            return t;
        } else {
            // Get attributes
            var a = {},
                r = t.get(0);
            if (r) {
                r = r.attributes;
                for (var i in r) {
                    var p = r[i];
 //                   if (typeof p.nodeValue !== 'undefined') a[p.nodeName] = p.nodeValue;
										if (typeof p.value !== 'undefined') a[p.nodeName] = p.value;
                }
            }
            return a;
        }
    };
})(jQuery);


// This is just here for various test
function testall(){
	
//	var xstr = '<html><head> <script>alert("HD")<\/script> <script src="zzz"><\/script> </head><body id="xbdy" class="xcl"><div id="out"><div id="div1">Hello world</div><div id="div2">Hi there</div></div></body></html>'

/*
var xstr = '<html ng-app><head> '+
        '<meta charset="UTF-8"></meta><title>Subsect Android</title> '+
        '<script src="/localjs/client.js"><\/script> ' +
        '<link rel="stylesheet" type="text/css" href="/localcss/client.css"> ' +
	'<script src="/localjs/client2.js"><\/script> ' +
    '</head><body><h1>HI</h1></body></html>'

	alert("xstr : " + xstr)

	var xhd = $.htmlDoc( xstr );
	*/
	
/*
	var xblob = new Blob(['alert("HI FRED")'], {type : 'text/javascript'})
			        var url = window.URL || window.webkitURL;
			        var srcpath= url.createObjectURL(xblob);
							var reader = new FileReader();
							reader.onload = function(){
							      alert("Blob : " + reader.result);
										xhd.find('head').children().get(1).innerHTML = reader.result;
										$('head').append(xhd.find('head').html())
							    };
							reader.readAsText(xblob)
		*/
				
//	$("html").attrs(xhd.filter("html").attrs()	)
//$.data(xhd.find("h1").get(0), "subsect_h1", "data added here")
//	alert("h1 : " + $.data(xhd.find("h1").get(0), "subsect_h1"))
	//alert("h1 : " + $(xqobj[0]).html())
	//						xhd.find('head').children().get(1).removeAttribute("src")
	//alert("Script : " + xhd.find('head').children().get(1).getAttribute("src"))
	
//	var lnstr = xhd.find('head').children('script[src$="t.js"]').get(0).src
//	alert("head script src: " + lnstr)
	
//	alert("base : " + lnstr.substr(lnstr.indexOf('///') + 2))
}
/**********************************************************************/

var peer = null
var conn = null;
var appPath = null;
var appFile = null;
var rcvbuffer = {};

var filecnt = 0;


var callbackdb = {};
var callcnt = 0;
var dbname = "";
var SYS_DIR = "sys";
var DB_SYS ="S_";
var DB_USR = "U_";


function subsect_useRTC(){
	return(true)
}


function initall(apath, aname, subname){
	
	appPath = apath;
	appName = aname;
	APPURL = "/pkg";
	LOCALSRC = "localsrc"

	dbname = getdbname();
	peerServerOn(subname);
}


function fullPath(locpath){
	
	return(appPath + locpath);
}

function peerServerOn(subname) {
	
	$.ajax({
	  type: "POST",
	  url: "https://service.xirsys.com/ice",
//		  dataType: "json",
	  data: {

	    ident: "markkudlac",
	    secret: "10633c0a-fb06-4502-a834-de7d1990c3e6",
	    domain: "subsect.net",
	    application: "subserver",
	    room: "default",
	
	    /*
	    ident: "rosemaryp",
	    secret: "ddb1722f-43ca-4a52-9eed-449875634cc9",
	    domain: "www.adladl.com",
	    application: "subserv",
	    room: "room-1",
			*/
	    secure: 1,
		timeout: 600
	  },
	  success: function (data, dstatus) {
		  console.log("XirSys ajax status : " + dstatus);
		peerClientOn(subname, "", data.d);
	  },
	  error: function() {
	    console.log("ERROR  XirSys");
		peerClientOn(subname, "", null);	//use Google default
	  }
	});
}



function peerClientOn(subname, peerid, customConfig){
	
	var opts = {key: 'wcf528rijzx8byb9',
										debug: 3,
						};
						
	if (customConfig != null) opts.config = customConfig;
									
	peer = new Peer(opts);
	
		peer.on('open', function(id) {
			
			if (peerid.length <= 0) {
				var devport=":3000"
	
				<% if (Rails.env.production? ) then %>
					devport = ""
				<% end %>
				
				$.getJSON("http://" +subname+ ".subsect.net"+devport+"/api/getrtcid/"+subname,
    		function(rtnobj){
    			if (rtnobj.rtn !== false) {
						if (rtnobj.status == "A") {
    					makeConnection(rtnobj.rtcid)
						} else {
							peerShutDown();
							clearspinner();
							alert(subname + " : Is not available currently")
						}
    			} else {
						peerShutDown();
						clearspinner();
    				alert("Peer id not found");
    			}
  			})
  			.fail(function(xhr, text){
					peerShutDown();
					clearspinner();
    			alert("Server call failed : " + text);
  			});
			} else {
				makeConnection(peerid);
			}
		});
		
		peer.on('error', function(err) {
			  alert('Peer client ERROR : ' + err.type + " : " + err.message);
			});
			
	  peer.on('disconnect', function() {
			alert('Peer client Disconnect event');
		});
}


function makeConnection(peerid){
	
	conn = peer.connect(peerid, {reliable: true});
	conn.on('disconected', function(){
		alert("Peer.connect DISCONNECTED");
	});
	
	conn.on('error', function(err){
		alert("Peer connect ERROR event : " + err.type + " : " + wrr.message);
	});
	callserver()
}


function peerShutDown(){
	if (peer != null) {
	        peer.disconnect();
	        peer.destroy();
	}
	peer = null;
}


function callserver() {
	
	var rcvhtml = null;
	var headflg = false
		
	conn.on('open', function() {
	  // Receive messages
	  conn.on('data', function(data) {
			
			var xblob;

			if (data.cnt == 0){
				xblob = new Blob([ new Uint8Array(data.blob) ], {type : data.blobtype});
			} else {
				if (data.cnt == 1) {
					rcvbuffer[data.uri] = {type: data.blobtype, block: []};
				}
				rcvbuffer[data.uri].block[data.cnt -  1] = new Uint8Array(data.blob);
				
				if (data.cnt == -1) {
					buflen = rcvbuffer[data.uri].block.length;  //add last block in
					rcvbuffer[data.uri].block[buflen] = new Uint8Array(data.blob);
					
					xblob = new Blob(rcvbuffer[data.uri].block, {type : data.blobtype});
			console.log("In data last block : " + data.cnt + "  blobsize : " +
					rcvbuffer[data.uri].block[0].length + " uri  " + data.uri);
				} else {
					console.log("In data loop : " + data.cnt + "  blobsize : " +
							rcvbuffer[data.uri].block[0].length);
							
					conn.send(xhrCall(data.uri, null, data.cnt));
					
					if (data.blobtype.indexOf("audio") == 0) {
						driveStream()
					}
					return
				}
			}
			
			processBlob(data, xblob);			
	  });

	  // Send messages
	  console.log("Call for app : "+ fullPath(appName.toLowerCase()) + ".html");
	  conn.send(xhrCall(fullPath(appName.toLowerCase()) + ".html"));
		});
}	

	
function processBlob(data, xblob){
//	console.log("processBlob all uri : " + data.uri + "  Type : "+ xblob.type);
	
	if (data.uri.indexOf('api/') >= 0 ){
	
//				console.log("api blob type : " + xblob.type);
		var reader = new FileReader();
		reader.onload = function(){
		
			var xread = JSON.parse(reader.result)
			var tmpfunc = callbackdb[xread[0].funcid];
			var tmpid = xread[0].funcid
		
			delete callbackdb.tmpid;
		
			if (tmpfunc !== undefined && tmpfunc != null){
				delete xread[0].funcid;
				setTimeout(tmpfunc, 0, xread);
			}
		}
	
		reader.readAsText(xblob);
	
	} else if (xblob.type.indexOf("text") == 0){
		var reader = new FileReader();
		reader.onload = function(){
//				      alert("Blob : " + reader.result);
//							console.log("Uri  : "+ data.uri)
			
				if (xblob.type.indexOf("html") > 0 ) {
				 rcvhtml = $.htmlDoc( reader.result );

				 filecnt = 0;
			 
// Clear image tags
				 clearimgsrc(rcvhtml);
			 
//				 var headtags = rcvhtml.find('head').children('script').get();
// Transfer attributes							 
				 $("body").attrs(rcvhtml.find('body').attrs());
				 $("head").attrs(rcvhtml.find('head').attrs());
				 $("html").attrs(rcvhtml.filter('html').attrs());
			 
				 processHead(rcvhtml);
				 return;
			 
				}	else if (xblob.type.indexOf("javascript") > 0 ||
						xblob.type.indexOf("ng-template") > 0) {
					var rmsrc = cleanURI(data.uri)
					var scrpt = rcvhtml.find('head').children('script[src$="'+rmsrc+'"]')
					scrpt.removeAttr("src")				
					scrpt.text(reader.result);
					filecnt--;
					loadhead(filecnt, rcvhtml);
				} else if (xblob.type.indexOf("css") > 0) {
					
					var rmsrc = cleanURI(data.uri)
					var linkcss = rcvhtml.find('head').children('link[href$="'+rmsrc+'"]')
				
	        var locurl = window.URL || window.webkitURL;
	        var hrefurl= locurl.createObjectURL(xblob);
//				console.log("for css data.uri : "+data.uri+"  Cleaned : "+rmsrc+"   hrefurl : "+hrefurl)
					linkcss.attr("href", hrefurl)
					filecnt--;
					loadhead(filecnt, rcvhtml);
				}
	    	};
		
//	console.log("data : "+ data.data)
			reader.readAsText(xblob)
		
		} else if (xblob.type.indexOf("image") == 0) {
// HTML will be inserted before any image manipulation
			var datatag
    		var url = window.URL || window.webkitURL;
    		var imgurl = url.createObjectURL(xblob);
		
		 $.each($('img').get(), function(){
			 datatag = $.data(this, LOCALSRC)
		 
			 if (datatag !== undefined) {
//					 	console.log("img data : " + datatag + " uri : " + data.uri)

				if (data.uri.indexOf(datatag) == 0){
			 		this.src=imgurl
			 	}
			}
		})
		
	} else if (xblob.type.indexOf("audio") == 0) {
			//Audio
//		console.log("Audio blob size : " + xblob.size + "  Type : "+xblob.type);
	
		endStream(data.uri);
	} else if (xblob.type.indexOf("subfile") == 0){
		
		var reader = new FileReader();
		var xtype = xblob.type;
		
		reader.onload = function(){

			var tmpid = xtype.split('/')[1];
			var tmpfunc = callbackdb[tmpid];
//			console.log("In subfile : "+ tmpid + " tmpfunc : "+tmpfunc);
			
			delete callbackdb.tmpid;
		
			if (tmpfunc !== undefined && tmpfunc != null){
				setTimeout(tmpfunc, 0, reader.result);
			}
		}
	
		reader.readAsText(xblob);
		
	}
	
	clearRcvBuffer(data.uri);
}
	
	
function processHead(rcvhtml){
		

/* This is a hack to force remote calls to behave syncronously
	This should be looked at later. requires all sync remote calls to be at
	the beginning of the <head>
*/

var headtags = rcvhtml.find('head').children('script').get();
var dump = false;
var thissrc;
//alert("In processHead : " + rcvhtml.find('head').children('script').get(1).outerHTML);

 	$.each(headtags, function(){
		
		this_src = this.getAttribute("src")
// console.log("script head tags attr src : "+ this_src)
		if (this_src != null && this_src.length > 0){	 
				 if (blockInclude(this_src)) {
				 	this.parentNode.removeChild(this);
				 } else if (islocalfile(this.src)){
					 filecnt++;
//					 console.log("extract head tags src : "+ this.src)
					 this.setAttribute("sub_src", this_src);
					 
					 var mimetp = "";
					 var xtyp = this.getAttribute("type");
					 if (xtyp != null && xtyp.indexOf("ng-template") > 0){
//									 console.log("set Angular mimetype")
							this.setAttribute("id", this_src);
							mimetp = "text/ng-template";
					 }

					 conn.send(xhrCall(fullPath(this_src),null,null,null,mimetp));
				 } else {
					 $.holdReady( true );
//					 console.log("remote before javscript send : " + this.src +
//				 "  filecnt : " + filecnt)
					 
					this.setAttribute("sub_src", this.src);
					var tmpsrc = this.src
					this.removeAttribute("src");
					
				 	$.getScript(tmpsrc, function(){
						$.holdReady( false );
//							console.log("returned from JV call")
						if (filecnt <= 0) {
							setTimeout(processHead, 0, rcvhtml)
						}
					
					}).fail(function(err,str){
						console.log("error getScript : " + str)
					})
					
					if (filecnt <= 0) {
//									console.log("filecnt <= 0 JV return")
						dump = true
						return false;
					}
		 	 	}
			}
		})

		if (!dump) {
			 headtags = rcvhtml.find('head').children('link[rel="stylesheet"]').get();
			 $.each(headtags, function(){
				 if (islocalfile(this.href)){
					 filecnt++;
					 conn.send(xhrCall(fullPath(this.getAttribute("href"))));
				 }
			 })
			 
			 loadhead(filecnt, rcvhtml);
		 }
	}
	
	
	function blockInclude(str){
		
		return (str.indexOf("dev_subsect.js") >= 0 );
	}
	
	
	function cleanURI(datauri) {
		
		return datauri.substr(datauri.indexOf(appName)+appName.length + APPURL.length)
	}
	
	
	function clearimgsrc(rcvhtml) {

		 $.each(rcvhtml.find('img').get(), function(){
//			 console.log("clear img src : " + this.src)
			 if (this.src.length > 1 && islocalfile(this.src)){
				 $.data(this, LOCALSRC, fullPath(this.getAttribute("src")))
			 	this.removeAttribute("src")
			 } else if (this.src == "#") this.removeAttribute("src");
		 })
		 
		 //Audio
		 $.each(rcvhtml.find('source').get(), function(){
			 if (this.src.length > 1 && islocalfile(this.src)){
				$.data(this, LOCALSRC, fullPath(this.getAttribute("src")))
			 	this.removeAttribute("src")
			 } else if (this.src == "#") this.removeAttribute("src");
		 })
	}
	
	
	function fetchimgsrc(){
		
	 $.each($('img').get(), function(){
		 if (! this.hasAttribute("src") && 
		 				$.data(this, LOCALSRC) !== undefined){
			 conn.send(xhrCall($.data(this, LOCALSRC)));
		 }
	 })
	 
	 $.each($('source').get(), function(){
		 if (! this.hasAttribute("src") && 
		 				$.data(this, LOCALSRC) !== undefined){
			 conn.send(xhrCall($.data(this, LOCALSRC)));
		 }
	 })
	}
	
	
	function processimg(el, imgsrc){
		
		if (imgsrc != null){
			$.data(el, LOCALSRC, fullPath(imgsrc))
		}
		conn.send(xhrCall(fullPath(imgsrc)))
	}
	
	
	function xhrCall(file, args, cnt, type, mimetp){
		
		if (!args) args = "";
		if (!cnt) cnt = 0;
		if (!type) type = "GET";
		if (!mimetp) mimetp = "";

		return({type: type, file: file, args: args, cnt: cnt, mimetp: mimetp});
	}
	
	
	function islocalfile(pathstr){
		return(window.location.host.length > 0 && pathstr.indexOf(window.location.host) >= 0)
	}
	
	
	function loadhead(filecnt, rcvhtml) {
		var tmp = [];
		var i = 0;
		if (filecnt == 0) {
			// This cleans up the spinner etc may not be best
			
			clearspinner();
				
			$('head').append(rcvhtml.find('head').children())
			$('body').append(rcvhtml.find('body').children());
			
			fetchimgsrc();
			
			$(function(){
				$("script[sub_src]").empty();
			})
			$.holdReady( false );
		}
	}
	

function driveStream() {
	
 $.each($('source').get(), function(){
//	  console.log("DriveStream tag: " + this.src + "  data : "+ $.data(this, LOCALSRC))
	 if (! this.hasAttribute("src") && $.data(this, LOCALSRC) !== undefined &&
 					bufferStart($.data(this, LOCALSRC))) {
						
						this.parentNode.removeEventListener("ended", streamEnd);
						playstream(this, $.data(this, LOCALSRC))
						this.parentNode.addEventListener("ended", streamEnd);
	 }
 })
}


function endStream(file) {
	
 $.each($('source').get(), function(){
	 if ($.data(this, LOCALSRC) !== undefined &&
 			$.data(this, LOCALSRC).indexOf(file) == 0) {
				this.parentNode.removeEventListener("ended", streamEnd);
				playstream(this, $.data(this, LOCALSRC))
			//	clearRcvBuffer(file);
	 }
 })
}


function clearRcvBuffer(bkey){
	rcvbuffer[bkey] = null;
}


function bufferStart(buffkey) {
	
	var xblock = rcvbuffer[buffkey].block;
	var tot = 0;
	
	for (i=0; i<xblock.length; i++){
		tot = tot + xblock[i].length;
	}
	return(tot > 500000);
}


function streamEnd(){
	
	$.each($(this).children('source'), function(){
		if ($.data(this, LOCALSRC) !== undefined){
			playstream(this, $.data(this, LOCALSRC))
		}
	})
}


function playstream(el, buffkey) {
						var timespot;
						var url = window.URL || window.webkitURL;
						var timedelay = 1000;
		        var audurl;
					
							el.parentNode.pause();
							timespot = el.parentNode.currentTime
//							console.log("Paused time  : " + timespot)
						
							if (el.src !== undefined && el.src.length > 0) {
//								console.log("In revoke");
								url.revokeObjectURL(el.src);
							} else {
								timedelay = 0;
							}
							
							audurl = url.createObjectURL(new Blob(rcvbuffer[buffkey].block,
														 	{type : rcvbuffer[buffkey].type}));
					 		el.src=audurl;
						
							setTimeout(function(){
							el.parentNode.load();
							el.parentNode.currentTime = timespot;
							el.parentNode.play();	
							}, timedelay)
}


function getParam(val) {

    tmp = [];
    var items = location.search.substr(1).split("&");
    for (var index = 0; index < items.length; index++) {
        tmp = items[index].split("=");
        if (tmp[0] === val) return(tmp[1]);
    }
    return "";
}	


function getdbname(){
		
	var xname = appPath.indexOf(SYS_DIR) == 0  ? DB_SYS : DB_USR;
	return (xname + appName);
}


function insertDB(table, values, func) {
	
	if (values == null || Object.keys(values).length == 0) {
		alert("Error: Insert values is empty")
		return;
	}

	var sqlpk = {db: dbname, table: table, values: values, funcid: funcID(func)}

	conn.send(xhrCall('api/insertDB', 'sqlpk='+ 
			encodeURIComponent(JSON.stringify(sqlpk)), 0, "POST"))
}


function queryDB(qstr, args, limits, func) {
	
	if (args == null) args = {};
	if (limits == null) limits = {};
	
	var sqlpk = {db: dbname, qstr: qstr, args: args,
					limits: limits, funcid: funcID(func)}
	
	conn.send(xhrCall('api/queryDB','sqlpk='+ 
			encodeURIComponent(JSON.stringify(sqlpk))))
}


function updateDB(table, values, qstr, args, func) {
	
	if (values == null || Object.keys(values).length == 0) {
		alert("Error: Update values is empty")
		return;
	}
	
	if (qstr == null) { qstr = "";}
	
	var sqlpk = {db: dbname, table: table, values: values,
						qstr: qstr, args: args, funcid: funcID(func)}

	conn.send(xhrCall('api/updateDB', 'sqlpk='+ 
			encodeURIComponent(JSON.stringify(sqlpk)), 0, "POST"))
}


function removeDB(table, qstr, args, func) {
	
	if (args == null || Object.keys(args).length == 0) {
		alert("Error: removeDB args is empty")
		return;
	}
	
	if (qstr == null) { qstr = ""	}
	
	var sqlpk = {db: dbname, table: table, qstr: qstr,
						args: args, funcid: funcID(func)}
	
	conn.send(xhrCall('api/removeDB', 'sqlpk='+ 
			encodeURIComponent(JSON.stringify(sqlpk))))
}


function getMenu(func){
	
	conn.send(xhrCall('api/getMenu/'+funcID(func)));
}


function getsubFile(xfile, func){
	conn.send(xhrCall(fullPath(xfile), null, 0, "GET", "subfile/"+funcID(func)));
}


function funcID(func){
	
	var funcidstr = "f_"+callcnt;
	
	++callcnt;
	callbackdb[funcidstr] = func;
	return(funcidstr);
}


function clearspinner(){
	
	$("#subinitrm").remove();
}

