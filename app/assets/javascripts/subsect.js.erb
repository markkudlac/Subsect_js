
//This is here to keep the ready from firing before dynamically defined
//Javascript loads

$.holdReady( true );


/* This must load after JQuery */

/*!
 * jQuery htmlDoc "fixer" - v0.2pre - 8/8/2011
 * http://benalman.com/projects/jquery-misc-plugins/
 *
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
(function($) {
  // RegExp that matches opening and closing browser-stripped tags.
  // $1 = slash, $2 = tag name, $3 = attributes
  var matchTag = /<(\/?)(html|head|body|title|base|meta)(\s+[^>]*)?>/ig;
  // Unique id prefix for selecting placeholder elements.
  var prefix = 'hd' + +new Date;
  // A node under which a temporary DOM tree can be constructed.
  var parent;
	
  $.htmlDoc = function(html) {
		
    // A collection of "intended" elements that can't be rendered cross-browser
    // with .innerHTML, for which placeholders must be swapped.
    var elems = $();
    // Input HTML string, parsed to include placeholder DIVs. Replace HTML,
    // HEAD, BODY tags with DIV placeholders.
    var htmlParsed = html.replace(matchTag, function(tag, slash, name, attrs) {
      // Temporary object in which to hold attributes.
      var obj = {};
      // If this is an opening tag...
      if ( !slash ) {
        // Add an element of this name into the collection of elements. Note
        // that if a string of attributes is added at this point, it fails.
        elems = elems.add('<' + name + '/>');
        // If the original tag had attributes, create a temporary div with
        // those attributes. Then, copy each attribute from the temporary div
        // over to the temporary object.
        if ( attrs ) {
          $.each($('<div' + attrs + '/>')[0].attributes, function(i, attr) {
						
            obj[attr.name] = attr.value;
          });
        }
        // Set the attributes of the intended object based on the attributes
        // copied in the previous step.
        elems.eq(-1).attr(obj);
      }
      // A placeholder div with a unique id replaces the intended element's
      // tag in the parsed HTML string.
      return '<' + slash + 'div'
        + (slash ? '' : ' id="' + prefix + (elems.length - 1) + '"') + '>';
    });

    // If no placeholder elements were necessary, just return normal
    // jQuery-parsed HTML.
    if ( !elems.length ) {
      return $(html);
    }
    // Create parent node if it hasn't been created yet.
    if ( !parent ) {
      parent = $('<div/>');
    }
    // Create the parent node and append the parsed, place-held HTML.
    parent.html(htmlParsed);
    // Replace each placeholder element with its intended element.
    $.each(elems, function(i) {
      var elem = parent.find('#' + prefix + i).before(elems[i]);
      elems.eq(i).html(elem.contents());
      elem.remove();
    });
    // Return the topmost intended element(s), sans text nodes, while removing
    // them from the parent element with unwrap.
    return parent.children().unwrap();
  };

}(jQuery));



// Copy all atributes over for elements
(function($) {
    // Attrs
    $.fn.attrs = function(attrs) {
        var t = $(this);
        if (attrs) {
            // Set attributes
            t.each(function(i, e) {
                var j = $(e);
                for (var attr in attrs) {
                    j.attr(attr, attrs[attr]);
                };
            });
            return t;
        } else {
            // Get attributes
            var a = {},
                r = t.get(0);
            if (r) {
                r = r.attributes;
                for (var i in r) {
                    var p = r[i];
 //                   if (typeof p.nodeValue !== 'undefined') a[p.nodeName] = p.nodeValue;
										if (typeof p.value !== 'undefined') a[p.nodeName] = p.value;
                }
            }
            return a;
        }
    };
})(jQuery);


// This is just here for various test
function testall(){
	
//	var xstr = '<html><head> <script>alert("HD")<\/script> <script src="zzz"><\/script> </head><body id="xbdy" class="xcl"><div id="out"><div id="div1">Hello world</div><div id="div2">Hi there</div></div></body></html>'

var xstr = '<html ng-app><head> '+
        '<meta charset="UTF-8"></meta><title>Subsect Android</title> '+
        '<script src="/localjs/client.js"><\/script> ' +
        '<link rel="stylesheet" type="text/css" href="/localcss/client.css"> ' +
	'<script src="/localjs/client2.js"><\/script> ' +
    '</head><body><h1>HI</h1></body></html>'

	alert("xstr : " + xstr)

	var xhd = $.htmlDoc( xstr );
/*
	var xblob = new Blob(['alert("HI FRED")'], {type : 'text/javascript'})
			        var url = window.URL || window.webkitURL;
			        var srcpath= url.createObjectURL(xblob);
							var reader = new FileReader();
							reader.onload = function(){
							      alert("Blob : " + reader.result);
										xhd.find('head').children().get(1).innerHTML = reader.result;
										$('head').append(xhd.find('head').html())
							    };
							reader.readAsText(xblob)
		*/
				
//	$("html").attrs(xhd.filter("html").attrs()	)
//$.data(xhd.find("h1").get(0), "subsect_h1", "data added here")
//	alert("h1 : " + $.data(xhd.find("h1").get(0), "subsect_h1"))
	//alert("h1 : " + $(xqobj[0]).html())
	//						xhd.find('head').children().get(1).removeAttribute("src")
	//alert("Script : " + xhd.find('head').children().get(1).getAttribute("src"))
	
//	var lnstr = xhd.find('head').children('script[src$="t.js"]').get(0).src
//	alert("head script src: " + lnstr)
	
//	alert("base : " + lnstr.substr(lnstr.indexOf('///') + 2))
}
/**********************************************************************/

var peer = null
var conn = null;
var appPath = null;
var appFile = null;
var rcvbuffer = {};

var filecnt = 0;

var callbackdb = {};
var callcnt = 0;
var dbname = "";
var SYS_DIR = "sys";
var DB_SYS ="S_";
var DB_USR = "U_";

	function initall(apath, aname, subname){
		
		appPath = apath;
		appName = aname;
		APPURL = "/app";
		LOCALSRC = "localsrc"
		
		dbname = getdbname();
		
		/*
	$('#clibut').on("click",function(){
		
		if ($("#clibut").text().indexOf("St") == 0){
			peerClientOn(subname, $('#peerid').val());
			
		} else {
			conn.close();
			conn = null;
			peer.destroy();
			peer = null;
			$("#clibut").remove()
		}
	});
		*/

		peerClientOn(subname, "");
	}
	
	
	function fullPath(locpath){
		
		return(appPath + locpath);
	}
	
	
	function peerClientOn(subname, peerid){
		peer = new Peer( {key: 'wcf528rijzx8byb9', debug: 3});
		
			peer.on('open', function(id) {
				
				if (peerid.length <= 0) {
					var devport=":3000"
		
					<% if (Rails.env.production? ) then %>
						devport = ""
					<% end %>
					
					$.getJSON("http://" +subname+ ".subsect.net"+devport+"/api/getrtcid/"+subname,
	    		function(rtnobj){
	    			if (rtnobj.rtcid.length > 0) {
	    				makeConnection(rtnobj.rtcid)
	    			} else {
	    				alert("Peer id not found")
	    			}
	  			})
	  			.fail(function(xhr, text){
	    			alert("Server call failed : " + text);
	  			});
				} else {
					makeConnection(peerid);
				}
			});
	}
	
	
	function makeConnection(peerid){
		
		conn = peer.connect(peerid, {reliable: true});
		$("#clibut").text("Close Client")
		callserver()
		
	}
	
	function callserver() {
		
		var rcvhtml = null;
		var headflg = false
		
		conn.on('open', function() {
		  // Receive messages
		  conn.on('data', function(data) {
				
				var xblob;

				if (data.cnt == 0){
					xblob = new Blob([ new Uint8Array(data.blob) ], {type : data.blobtype});
				} else {
					if (data.cnt == 1) {
						rcvbuffer[data.uri] = {type: data.blobtype, block: []};
					}
					rcvbuffer[data.uri].block[data.cnt -  1] = new Uint8Array(data.blob);
					
					if (data.cnt == -1) {
						console.log("Returning from data loop");
						xblob = new Blob(rcvbuffer[data.uri].block, {type : data.blobtype});
					} else {
						console.log("In data loop : " + data.cnt + "  blobsize : " +
								rcvbuffer[data.uri].block[0].length);
								
						conn.send(xhrCall(data.uri, data.cnt));
						
						if (data.blobtype.indexOf("audio") == 0) {
							driveStream()
						}
						return
					}
				}
				
				console.log("all uri : " + data.uri + "  Type : "+ xblob.type);
				if (data.uri.indexOf('api/') >= 0 ){
					
					console.log("api blob type : " + xblob.type);
					var reader = new FileReader();
					reader.onload = function(){
						
						var xread = JSON.parse(reader.result)
						var tmpfunc = callbackdb[xread[0].funcid];
						var tmpid = xread[0].funcid
//	console.log("funcid : " + tmpid)
//						alert("In api result : " + reader.result);
						
						delete callbackdb.tmpid;
						
						if (tmpfunc !== undefined && tmpfunc != null){
							delete xread[0].funcid;
							setTimeout(tmpfunc, 0, xread);
						}
					}
					
					reader.readAsText(xblob);
					
				} else if (xblob.type.indexOf("text") == 0){
					var reader = new FileReader();
					reader.onload = function(){
//				      alert("Blob : " + reader.result);
							console.log("Uri  : "+ data.uri)
							
							if (xblob.type.indexOf("html") > 0 ) {
							 rcvhtml = $.htmlDoc( reader.result );
							 filecnt = 0;
							 
// Clear image tags
							 clearimgsrc(rcvhtml);
							 
							 var headtags = rcvhtml.find('head').children('script').get();
// Transfer attributes							 
							 $("body").attrs(rcvhtml.find('body').attrs());
							 $("head").attrs(rcvhtml.find('head').attrs());
							 $("html").attrs(rcvhtml.filter('html').attrs());
							 
							 console.log("Number head tags before processHead : "+ headtags.length)
							 processHead(rcvhtml);
							 return;
							 
							}	else if (xblob.type.indexOf("javascript") > 0 ||
									xblob.type.indexOf("ng-template") > 0) {
								var rmsrc = cleanURI(data.uri)
								var scrpt = rcvhtml.find('head').children('script[src$="'+rmsrc+'"]')
								scrpt.removeAttr("src")
								scrpt.html(reader.result)
								filecnt--;
								loadhead(filecnt, rcvhtml);
							} else if (xblob.type.indexOf("css") > 0) {
								var rmsrc = cleanURI(data.uri)
								var linkcss = rcvhtml.find('head').children('link[href$="'+rmsrc+'"]')
								
				        var locurl = window.URL || window.webkitURL;
				        var hrefurl= locurl.createObjectURL(xblob);
								
								linkcss.attr("href", hrefurl)
								filecnt--;
								loadhead(filecnt, rcvhtml);
							}
				    };
						
	//					console.log("data : "+ data.data)
						reader.readAsText(xblob)
						
					} else if (xblob.type.indexOf("image") == 0) {
	// HTML will be inserted before any image manipulation
						var datatag
		        var url = window.URL || window.webkitURL;
		        var imgurl = url.createObjectURL(xblob);
						
					 $.each($('img').get(), function(){
						 datatag = $.data(this, LOCALSRC)
						 
						 if (datatag !== undefined) {
						 	console.log("img data : " + datatag + " uri : " + data.uri)

							if (data.uri.indexOf(datatag) == 0){
						 		this.src=imgurl
						 	}
						}
					})
						
				} else if (xblob.type.indexOf("audio") == 0) {
						//Audio
					console.log("Audio blob size : " + xblob.size + "  Type : "+xblob.type);
					
					endStream(data.uri);
					}
		  });

		  // Send messages
		  conn.send(xhrCall(fullPath(appName.toLowerCase()) + ".html"));
			startPing()
			});
	}	
	
	
function processHead(rcvhtml){
		
		
		/* This is a hack to force remote calls to behave syncronously
				This should be looked at later. requires all sync remote calls to be at
				the beginning of the <head>
	*/
	
		var headtags = rcvhtml.find('head').children('script').get();
		
//		console.log("ENTER PROCESSHEAD")
		var dump = false;
		
			 $.each(headtags, function(){
//								 console.log("script head tags src : "+ this.src)
				 if (this.src != null && this.src.length > 0){	 
								 if (blockInclude(this.src)) {
								 	this.parentNode.removeChild(this);
								 } else if (islocalfile(this.src)){
									 filecnt++;
//									 console.log("extract head tags src : "+ extractpath(this.src))
									 
									 this.setAttribute("sub_src", this.src);
									 
									 var mimetp = "";
									 var xtyp = this.getAttribute("type");
									 if (xtyp != null && xtyp.indexOf("ng-template") > 0){
	//									 console.log("set Angular mimetype")
									 		this.setAttribute("id", extractpath(this.src));
											mimetp = "text/ng-template";
									 }
									 conn.send(xhrCall(fullPath(extractpath(this.src)),null,null,mimetp));
								 } else {
									 $.holdReady( true );
									 console.log("remote before javscript send : " + this.src +
								 "  filecnt : " + filecnt)
									 
 									this.setAttribute("sub_src", this.src);
									var tmpsrc = this.src
 									this.removeAttribute("src");
									
								 	$.getScript(tmpsrc, function(){
										$.holdReady( false );
										console.log("returned from JV call")
										if (filecnt <= 0) {
											setTimeout(processHead, 0, rcvhtml)
										}
									
									}).fail(function(err,str){
										console.log("error getScript : " + str)
									})
										 
	//								this.setAttribute("sub_src", this.src);
	//								this.removeAttribute("src");
									
									if (filecnt <= 0) {
	//									console.log("filecnt <= 0 JV return")
										dump = true
										return false;
									}
						 	 	}
							}
					})
		
					if (!dump) {
							 headtags = rcvhtml.find('head').children('link[rel="stylesheet"]').get();
							 $.each(headtags, function(){
								 if (islocalfile(this.href)){
									 filecnt++;
									 conn.send(xhrCall(fullPath(extractpath(this.href))));
								 }
							 })
							 
							 loadhead(filecnt, rcvhtml);
						 }
	}
	
	
	function startPing() {
		
		if (conn != null) {
			conn.send(xhrCall("sub_ping"))
			setTimeout(startPing, 30000);
		}
	}
	
	
	function blockInclude(str){
		
		return (str.indexOf("jquery-") >= 0 || str.indexOf("dev_subsect.js") >= 0 );
	}
	
	
	function cleanURI(datauri) {
		
		return datauri.substr(datauri.indexOf(appName)+appName.length + APPURL.length)
	}
	
	
	function clearimgsrc(rcvhtml) {

		 $.each(rcvhtml.find('img').get(), function(){
//			 console.log("clear img src : " + this.src)
			 if (this.src.length > 1 && islocalfile(this.src)){
			 	$.data(this, LOCALSRC, fullPath(extractpath(this.src)))
			 	this.removeAttribute("src")
			 } else if (this.src == "#") this.removeAttribute("src");
		 })
		 
		 //Audio
		 $.each(rcvhtml.find('source').get(), function(){
			 if (this.src.length > 1 && islocalfile(this.src)){
			 	$.data(this, LOCALSRC, fullPath(extractpath(this.src)))
			 	this.removeAttribute("src")
			 } else if (this.src == "#") this.removeAttribute("src");
		 })
	}
	
	
	function fetchimgsrc(){
		
	 $.each($('img').get(), function(){
//		  console.log("fetchimg  : " + this.src + "  data : "+ $.data(this, LOCALSRC))
		 if (! this.hasAttribute("src") && 
		 				$.data(this, LOCALSRC) !== undefined){
			 conn.send(xhrCall($.data(this, LOCALSRC)));
		 }
	 })
	 
	 $.each($('source').get(), function(){
		 if (! this.hasAttribute("src") && 
		 				$.data(this, LOCALSRC) !== undefined){
			 conn.send(xhrCall($.data(this, LOCALSRC)));
		 }
	 })
	}
	
	
	function processimg(el, imgsrc){
		
		if (imgsrc != null){
			$.data(el, LOCALSRC, fullPath(imgsrc))
		}
		conn.send(xhrCall(fullPath(imgsrc)))
	}
	
	
	function xhrCall(file, cnt, type, mimetp){
		
		if (!cnt) cnt = 0;
		if (!type) type = "GET";
		if (!mimetp) mimetp = "";

		return({type: type, file: file, cnt: cnt, mimetp: mimetp});
	}
	
	
	function islocalfile(pathstr){
		
		if (pathstr.indexOf("file:") == 0) return true
		return(location.host.length > 0 && pathstr.indexOf(location.host) >= 0)
	}
	
	
	function extractpath(pathstr){
		
/************* This is bad and needs to be looked at later *****************/
		
		if (pathstr.indexOf("file:") == 0) return pathstr.substr(pathstr.indexOf('///') + 2);
		
		var hostoff = pathstr.indexOf(location.host);
		if ( location.host.length > 0 && hostoff >= 0) {
			
			var xpath = pathstr.substr(hostoff + location.host.length+4)
			if (xpath.indexOf('/') == 0) xpath = xpath.substr(1)
//				console.log("raw ex 1 : " + pathstr + " path : " + xpath)
			return  xpath;
		} else {
			return pathstr;
		}
	}
	
	
	function loadhead(filecnt, rcvhtml) {
		var tmp = [];
		var i = 0;
		if (filecnt == 0) {
			$('head').append(rcvhtml.find('head').children())
			$('body').append(rcvhtml.find('body').children());
			
			fetchimgsrc();
			
			$(function(){
				$("script[sub_src]").empty();
			})
			$.holdReady( false );
		}
	}
	

function tagWithHref(ev) {

ev.preventDefault();

	var xhref = $(this).attr("href")
	
	if (xhref.indexOf("http") < 0){
		xhref = "http://" + location.host + "/" + xhref
	}
//	console.log("tag href : "+xhref)
	location.assign(xhref);
}


function driveStream() {
	
 $.each($('source').get(), function(){
//	  console.log("DriveStream tag: " + this.src + "  data : "+ $.data(this, LOCALSRC))
	 if (! this.hasAttribute("src") && $.data(this, LOCALSRC) !== undefined &&
 					bufferStart($.data(this, LOCALSRC))) {
						
						this.parentNode.removeEventListener("ended", streamEnd);
						playstream(this, $.data(this, LOCALSRC))
						this.parentNode.addEventListener("ended", streamEnd);
	 }
 })
}


function endStream(file) {
	
 $.each($('source').get(), function(){
	 if ($.data(this, LOCALSRC) !== undefined &&
 					$.data(this, LOCALSRC).indexOf(file) == 0) {
						this.parentNode.removeEventListener("ended", streamEnd);
						playstream(this, $.data(this, LOCALSRC))
						rcvbuffer[file] = null;
	 }
 })
}


function bufferStart(buffkey) {
	
	var xblock = rcvbuffer[buffkey].block;
	var tot = 0;
	
	for (i=0; i<xblock.length; i++){
		tot = tot + xblock[i].length;
	}
	return(tot > 500000);
}


function streamEnd(){
	
	$.each($(this).children('source'), function(){
		if ($.data(this, LOCALSRC) !== undefined){
			playstream(this, $.data(this, LOCALSRC))
		}
	})
}


function playstream(el, buffkey) {
						var timespot;
						var url = window.URL || window.webkitURL;
						var timedelay = 1000;
		        var audurl;
					
							el.parentNode.pause();
							timespot = el.parentNode.currentTime
							console.log("Paused time  : " + timespot)
						
							if (el.src !== undefined && el.src.length > 0) {
//								console.log("In revoke");
								url.revokeObjectURL(el.src);
							} else {
								timedelay = 0;
							}
							
							audurl = url.createObjectURL(new Blob(rcvbuffer[buffkey].block,
														 	{type : rcvbuffer[buffkey].type}));
					 		el.src=audurl;
						
							setTimeout(function(){
							el.parentNode.load();
							el.parentNode.currentTime = timespot;
							el.parentNode.play();	
							}, timedelay)
}
	

function getdbname(){
		
	var xname = appPath.indexOf(SYS_DIR) == 0  ? DB_SYS : DB_USR;
	return (xname + appName);
}


function insertDB(table, values, func) {
	
	if (values == null || Object.keys(values).length == 0) {
		alert("Error: Insert values is empty")
		return;
	}
	
	var sqlpk = {db: dbname, table: table, values: values, funcid: funcID(func)}
	
	conn.send(xhrCall('api/insertDB?sqlpk='+ 
			encodeURIComponent(JSON.stringify(sqlpk))))
}


function queryDB(qstr, args, limits, func) {
	
	if (args == null) args = {};
	if (limits == null) limits = {};
	
	var sqlpk = {db: dbname, qstr: qstr, args: args,
					limits: limits, funcid: funcID(func)}
	
	conn.send(xhrCall('api/queryDB?sqlpk='+ 
			encodeURIComponent(JSON.stringify(sqlpk))))
}


function updateDB(table, values, qstr, args, func) {
	
	if (values == null || Object.keys(values).length == 0) {
		alert("Error: Update values is empty")
		return;
	}
	
	if (qstr == null) { qstr = "";}
	
	var sqlpk = {db: dbname, table: table, values: values,
						qstr: qstr, args: args, funcid: funcID(func)}
	
	conn.send(xhrCall('api/updateDB?sqlpk='+ 
			encodeURIComponent(JSON.stringify(sqlpk))))
}


function removeDB(table, qstr, args, func) {
	
	if (args == null || Object.keys(args).length == 0) {
		alert("Error: removeDB args is empty")
		return;
	}
	
	if (qstr == null) { qstr = ""	}
	
	var sqlpk = {db: dbname, table: table, qstr: qstr,
						args: args, funcid: funcID(func)}
	
	conn.send(xhrCall('api/removeDB?sqlpk='+ 
			encodeURIComponent(JSON.stringify(sqlpk))))
}


function funcID(func){
	
	var funcidstr = "F_"+callcnt;
	
	++callcnt;
	callbackdb[funcidstr] = func;
	return(funcidstr);
}